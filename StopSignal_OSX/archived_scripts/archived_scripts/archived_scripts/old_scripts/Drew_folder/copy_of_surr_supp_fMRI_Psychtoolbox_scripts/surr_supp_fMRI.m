%TO DO:% anti-aliasing of spokes and rings% test gap between annulus and surroundclear all; close all;params = SurroundParams_fMRI;AssertOpenGL;%cd('/Applications/MATLAB71/toolbox/matlab/michael_silver/OSX/');%cd('/Users/scanner3t/Desktop/Experiments/SilverLab/OSX/');%cd('/Applications/MATLAB_R2007b/toolbox/matlab/michael_silver/OSX/');HideCursor;Screen('Preference','VisualDebugLevel',0);Screen('Preference','SkipSyncTests',1);Priority(9); %0 for debugging; 9 for data collection% Get parametersfix.size = params.fixationSize;fix.type = params.type;fix.targetSize = 3;fix.targetLum = 100;fix.target = 1;%%% Open the screen %%%if params.scanner == 1    display = loadDisplayParams_OSX('displayName','Minor_582D_surround','cmapDepth',8);    %display = openScreen_OSX(display);    display.flip = 0;elseif params.scanner == 2    display = loadDisplayParams_OSX('displayName', 'Varian_scanner', 'cmapDepth', 8);	%display = openScreen_OSX(display);    display.flip = 0;elseif params.scanner == 3     display = loadDisplayParams_OSX('displayName', 'NNL', 'cmapDepth', 8);	%display = openScreen_OSX(display);    display.flip = 0;    display.keyboarddevnum=3;    display.keypaddevnum=3;    display.forpnum = 2;elseif params.scanner == 4     display = loadDisplayParams_OSX('displayName', 'jong_laptop', 'cmapDepth', 8);	display = openScreen_OSX(display);    display.flip = 0;elseif params.scanner == 5    display = loadDisplayParams_OSX('displayName', 'Avotec_3T', 'cmapDepth', 8);    %display = openScreen_OSX(display);    display.flip = 0;endbkColorNum = findName(display.reservedColor,'background');[display.windowPtr,display.rect] = Screen('OpenWindow',display.screenNumber,[],[],[],2);display.reservedColor(4).name = 'fixation_target';display.reservedColor(4).fbVal = 3;display.reservedColor(4).gunVal = [params.fixLum params.fixLum params.fixLum];%%% Create stimuli %%%% Create color maps - 1 sequence of color maps for all possible contrasts -% differences in contrast are built into the stimulicolormap = makeFlickerCmap_surround_fMRI(display,params);contrastvals = linspace(params.contrastRange(1), params.contrastRange(2), params.contrastIncrements);for contrast = 1:params.contrastIncrements   %for loc = 1:18  %1 through 8 possible locations for no surround, 9 is target-absent/no surround%                   % 10 through 17 are possible locations for surround, 18 is target-absent/surroundfor loc = 1:27 %1 through 8 possible locations for no surround, 9 is target-absent/no surround                    % 10 through 17 are possible locations for parallel surround, 18 is target-absent/parallel surround                    % 19 through 26 are possible locations for orthogonal                    % surround, 27 is target-absent/orthogonal surround		stimulus(contrast,loc).contrast = contrastvals(contrast);		stimulus(contrast,loc).cmap = colormap;		stimulus(contrast,loc).seq = [1, -(2:size(stimulus(contrast,loc).cmap, 3))];	endend%Create static image (wheel)outer = angle2pix(display, params.surroundSize(2));% [x,y] is a mesh grid in visual angle coordinatesxx = linspace(-params.surroundSize(2), params.surroundSize(2), (outer * 2));[x, y] = meshgrid(xx);r = sqrt(x.^2 + y.^2);mask = r > params.size(1) & r < params.size(2);innerring = ((r > params.size(1) - (params.RingWidth / 2)) & (r < params.size(1) + (params.RingWidth / 2)));outerring = ((r > params.size(2) - (params.RingWidth / 2)) & (r < params.size(2) + (params.RingWidth / 2)));image_Sta = innerring + outerring;image_Rings = image_Sta * params.StaRange(1);spokewidth = angle2pix(display, params.SpokeWidth);spokes = zeros(length(xx), length(xx));spokes(:,((round(length(xx)/2)))) = 1;spokes(((round(length(xx)/2))),:) = 1;for counter = 1:round(spokewidth/2)	spokes(:,((round(length(xx)/2)) - counter)) = 1;	spokes(:,((round(length(xx)/2)) + counter)) = 1;	spokes(((round(length(xx)/2)) - counter),:) = 1;	spokes(((round(length(xx)/2)) + counter),:) = 1;endspokes = ceil(((spokes + imrotate(spokes, (360 / params.regions), 'crop') + ...	imrotate(spokes, (720 / params.regions), 'crop') + imrotate(spokes, (1080 / params.regions),'crop')) .* mask) / 2);	image_Spokes = spokes * params.StaRange(1);image_Sta = ceil((image_Rings + image_Spokes)/2); %insures all values are 0 or 1% Create stimulitempimage_Sta = 1 - image_Sta;for loc = 1:27 %1 through 8 possible locations for no surround, 9 is target-absent/no surround                    % 10 through 17 are possible locations for parallel surround, 18 is target-absent/parallel surround                    % 19 through 26 are possible locations for orthogonal surround, 27 is target-absent/orthogonal surround    Screen('DrawText', display.windowPtr, sprintf('Loading %i of %i', loc, 27), display.rect(3)/2, display.rect(4)/2);    Screen('Flip', display.windowPtr);    for contrast = 1:params.contrastIncrements        gratings(contrast,loc).img = makeSurroundGrating_fMRI(display,params,loc,contrastvals(contrast));        gratings(contrast,loc).img = (gratings(contrast,loc).img .* tempimage_Sta) + image_Sta;        %gratings(contrast,loc).img = insertFix_surround_fMRI(display,gratings(contrast,loc).img, fix);warning('off')        gratings(contrast,loc).img = cast(gratings(contrast,loc).img, 'uint8');		stimulus(contrast,loc).stim = createStimulusStruct(gratings(contrast,loc).img,...			stimulus(contrast,loc).cmap, stimulus(contrast,loc).seq);        %stimulus(contrast,loc).stim.texture = ...        %    Screen('MakeTexture', display.windowPtr, double(gratings(contrast,loc).img));	endendfix.target = 0;% Create null stimulusnimg = image_Sta;nimg = insertFix_surround_fMRI(display, nimg, fix);cmap = colormap(:,:,1);seq = [-1 1];null = createStimulusStruct(nimg, cmap, seq);null.texture = Screen('MakeTexture', display.windowPtr, nimg);%Create null stimulus with diamond fixpointnulldiaimg = image_Sta;fix.type = 'diamond'; fix.size = params.fixationSize * 1.5;nulldiaimg = insertFix_surround_fMRI(display, nulldiaimg, fix);fix.type = 'black_square'; fix.size = params.fixationSize;nulldia = createStimulusStruct(nulldiaimg,cmap,seq);nulldia.texture = Screen('MakeTexture', display.windowPtr, nulldiaimg);%Create blank screenblankscreen = zeros(size(nimg));bs = createStimulusStruct(blankscreen, cmap, seq);bs.texture = Screen('MakeTexture',display.windowPtr,blankscreen);%Create null stimulus with parallel surroundparnullimg = makeSurroundGrating_fMRI(display,params,18,-1); %-1 contrast indicates surround onlyparnullimg = (parnullimg .* tempimage_Sta) + image_Sta;parnullimg = insertFix_surround_fMRI(display, parnullimg, fix);cmap = colormap;seq = [1, -(2:size(cmap, 3))];parnull = createStimulusStruct(parnullimg, cmap, seq);parnull.texture = Screen('MakeTexture', display.windowPtr, parnullimg);%Create null stimulus with dimaond fixpoint and parallel surroundfix.type = 'diamond'; fix.size = params.fixationSize * 1.5;pardiaimg = makeSurroundGrating_fMRI(display,params,18,-1); %-1 contrast indicates surround onlypardiaimg = (pardiaimg .* tempimage_Sta) + image_Sta;pardiaimg = insertFix_surround_fMRI(display,pardiaimg, fix);fix.type = 'black_square'; fix.size = params.fixationSize;pardia = createStimulusStruct(pardiaimg, cmap, seq);pardia.texture = Screen('MakeTexture', display.windowPtr, pardiaimg);%Create null stimulus with orthogonal surroundorthnullimg = makeSurroundGrating_fMRI(display,params,27,-1); %-1 contrast indicates surround onlyorthnullimg = (orthnullimg .* tempimage_Sta) + image_Sta;orthnullimg = insertFix_surround_fMRI(display, orthnullimg, fix);orthnull = createStimulusStruct(orthnullimg, cmap, seq);orthnull.texture = Screen('MakeTexture', display.windowPtr, orthnullimg);%Create null stimulus with diamond fixpoint and orthogonal surroundfix.type = 'diamond'; fix.size = params.fixationSize * 1.5;orthdiaimg = makeSurroundGrating_fMRI(display,params,27,-1); %-1 contrast indicates surround onlyorthdiaimg = (orthdiaimg .* tempimage_Sta) + image_Sta;orthdiaimg = insertFix_surround_fMRI(display, orthdiaimg, fix);fix.type = 'black_square'; fix.size = params.fixationSize;orthdia = createStimulusStruct(orthdiaimg, cmap, seq);orthdia.texture = Screen('MakeTexture', display.windowPtr, orthdiaimg);fix.target = 1;% Make auditory feedback sounds:soundFeedback.noResponseSound = soundFreqSweep(200, 300, .1);soundFeedback.correctResponseSound = {soundFreqSweep(300, 800, .1), soundFreqSweep(6500, 200, .1)};soundFeedback.incorrectResponseSound = soundFreqSweep(8000, 200, .1);responseSound = soundFreqSweep(3000, 1800, .07);%ASR: Changed it from '12', etc to '67' etc, for the Davis scannerif params.feedback == 1	onResponseSet = '67';	offResponseSet = '76';	answerType = 'binary';else	onResponseSet = '67';	offResponseSet = '67';	answerType = 'binary';end% Make trials% contrast, location (contrast = 1, location = 28 means get response (target present);% contrast = 2, location = 28 means get response (target absent);% contrast = 3, location = 28 means clear screen at end of run% contrast = 4, location = 28 means present just null stimulus (no annulus gratings)% contrast = 5, location = 28 means parallel surround (no annulus gratings)% contrast = 6, location = 28 means orthogonal surround (no annulus gratings)% contrast = 7, location = 28 means just wait with null stimulus for "response" and "feedback" periods% contrast = 8, location = 28 means null stimulus with diamond fixpoint (no annulus gratings)% contrast = 9, location = 28 means parallel surround with diamond fixpoint (no annulus gratings)% contrast = 10, location = 28 means orthogonal surround with diamond fixpoint (no annulus gratings)% contrast = 11, location = 28 means just wait with null stimulus with diamond fixpoint for "response" and "feedback" periods% contrast = 12, location = 28 means get response (target present), diamond fixpoint% contrast = 13, location = 28 means get response (target absent), diamond fixpointfor contrast = 1:params.contrastIncrements    for loc = 1:27 %1 through 8 possible locations for no surround, 9 is target-absent/no surround                    % 10 through 17 are possible locations for parallel surround, 18 is target-absent/parallel surround                    % 19 through 26 are possible locations for orthogonal surround, 27 is target-absent/orthogonal surround                		trials{contrast,loc} = addTrialEvent(display,[],'stimulusEvent','stimulus',...			stimulus(contrast,loc).stim,'duration',params.stimulusDuration);		trialdurations(contrast,loc) = params.stimulusDuration;    endend% target presenttrials{1,28} = addTrialEvent(display, [], 'responseEvent','stimulus',null,...    'duration', params.responseDuration, 'answerType',answerType,'responseSet',onResponseSet);if params.feedback == 1	trials{1,28} = addTrialEvent(display, trials{1,28},'soundFeedbackEvent',soundFeedback);endtrialdurations(1,28) = params.responseDuration + params.feedbackDuration;% target absenttrials{2,28} = addTrialEvent(display, [], 'responseEvent','stimulus',null,...    'duration', params.responseDuration, 'answerType',answerType,'responseSet',offResponseSet);if params.feedback == 1	trials{2,28} = addTrialEvent(display, trials{2,28},'soundFeedbackEvent',soundFeedback);endtrialdurations(2,28) = params.responseDuration + params.feedbackDuration;%clear screentrials{3,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',bs);trialdurations(3,28) = .01;%no surround (no annulus gratings)trials{4,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',null,'duration',params.stimulusDuration);trialdurations(4,28) = params.stimulusDuration;%parallel surround (no annulus gratings)trials{5,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',parnull,'duration',params.stimulusDuration);trialdurations(5,28) = params.stimulusDuration;%orthogonal surround (no annulus gratings)trials{6,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',orthnull,'duration',params.stimulusDuration);trialdurations(6,28) = params.stimulusDuration;%just wait with null stimulus during "response" periodtrials{7,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',null,'duration',.01);trialdurations(7,28) = params.responseDuration + params.feedbackDuration;%no surround with diamond fixpoint (no annulus gratings)trials{8,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',nulldia,'duration',params.stimulusDuration);trialdurations(8,28) = params.stimulusDuration;%parallel surround with diamond fixpoint (no annulus gratings)trials{9,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',pardia,'duration',params.stimulusDuration);trialdurations(9,28) = params.stimulusDuration;%orthogonal surround with diamond fixpoint (no annulus gratings)trials{10,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',orthdia,'duration',params.stimulusDuration);trialdurations(10,28) = params.stimulusDuration;%just wait with null stimulus with diamond fixpoint for "response" and "feedback" periodstrials{11,28} = addTrialEvent(display,[],'stimulusEvent','stimulus',nulldia,'duration',.01);trialdurations(11,28) = params.responseDuration + params.feedbackDuration;%get response, target present (diamond fixpoint)trials{12,28} = addTrialEvent(display, [], 'responseEvent','stimulus',nulldia,...    'duration',params.responseDuration, 'answerType',answerType,'responseSet',onResponseSet);if params.feedback == 1    trials{12,28} = addTrialEvent(display, trials{12,28},'soundFeedbackEvent',soundFeedback);endtrialdurations(12,28) = params.responseDuration + params.feedbackDuration;%get response, target absent (diamond fixpoint)trials{13,28} = addTrialEvent(display, [],'responseEvent','stimulus',nulldia,...    'duration',params.responseDuration,'answerType',answerType,'responseSet',offResponseSet);if params.feedback == 1    trials{13,28} = addTrialEvent(display, trials{13,28},'soundFeedbackEvent',soundFeedback);endtrialdurations(13,28) = params.responseDuration + params.feedbackDuration;% Create scan structuredoScanStruct.trials = trials;doScanStruct.trialDuration = trialdurations;doScanStruct.fix = fix;startStep(1:3) = round(params.contrastIncrements/2);startStep(4:7) = round(params.sizeIncrements/2);for sesscounter = 1:params.numberScans	doScanStruct.trialSequence = params.scanSequence(sesscounter);    if params.scanSequence(sesscounter) >= 1 & params.scanSequence(sesscounter) <= 3 %attend to annulus        params.dispString = 'DETECT IN ANNULUS';    elseif params.scanSequence(sesscounter) >= 4 & params.scanSequence(sesscounter) <= 6 %attend to fix        if sesscounter == 1 %no preceding playback sequence            playbackfile = inputdlg('file name for playback?');            cd ../Results            playbackinfo = load(char(playbackfile));            scanHistory{sesscounter}.playbackfile = char(playbackfile);            playbackscan = inputdlg('which scan to playback?');            playbackscan = str2num(playbackscan{1});            scanHistory{sesscounter}.playbackscan = playbackscan;            doScanStruct.matchseqContrast = playbackinfo.results(playbackscan).scanHistory.contrast;            doScanStruct.matchseqLoc = playbackinfo.results(playbackscan).scanHistory.stimloc;        else            doScanStruct.matchseqContrast = scanHistory{sesscounter-1}.contrast;            doScanStruct.matchseqLoc = scanHistory{sesscounter-1}.stimloc;        end        params.dispString = 'DETECT AT FIXATION';    elseif params.scanSequence(sesscounter) == 7 %attend to fix, no replay        params.dispString = 'DETECT AT FIXATION - PRACTICE';    end	doScanStruct.startStep = startStep(params.scanSequence(sesscounter));    doScanStruct.whichCondition = params.scanSequence(sesscounter);    scanHistory{sesscounter} = doScan_surround_fMRI(display, doScanStruct, params, [], 1);	disp(sprintf('Scan # %d', sesscounter));		startStep(params.scanSequence(sesscounter)) = scanHistory{sesscounter}.contrast(length(scanHistory{sesscounter}.contrast));        %use last contrast of this scan as first contrast of next scan    scanHistory{sesscounter}.actualcontrast = contrastvals(scanHistory{sesscounter}.contrast);    scanHistory{sesscounter}.whichCondition = doScanStruct.whichCondition;    if params.feedback == 1 %response of 1 is correct; response of 0 is incorrect		for respcounter = 1:length(scanHistory{sesscounter}.responses)			if isnan(scanHistory{sesscounter}.responses(respcounter))				scanHistory{sesscounter}.actualresponses(respcounter) = NaN;			elseif scanHistory{sesscounter}.responses(respcounter) == 1 %correct				if scanHistory{sesscounter}.correctanswer(respcounter) == 1 %stimulus present					scanHistory{sesscounter}.actualresponses(respcounter) = 1;				else %stimulus absent					scanHistory{sesscounter}.actualresponses(respcounter) = 0;				end %stimulus present or absent			elseif scanHistory{sesscounter}.responses(respcounter) == 0 %incorrect				if scanHistory{sesscounter}.correctanswer(respcounter) == 1 %stimulus present					scanHistory{sesscounter}.actualresponses(respcounter) = 0;				else %stimulus absent					scanHistory{sesscounter}.actualresponses(respcounter) = 1; 				end %stimulus present or absent			end %response NaN, correct, or incorrect		end %respcounter loop	else %response of 1 is subject thought target was present (button press 1); response of 0 is subject thought target was absent (button press 2)		scanHistory{sesscounter}.actualresponses = scanHistory{sesscounter}.responses;	end %feedback or no	    %Calculate and display quick summary of performance	ok = find(~isnan(scanHistory{sesscounter}.actualresponses));	ll = length(ok);	if ll > 0		correct = scanHistory{sesscounter}.correctanswer(ok);		nr = scanHistory{sesscounter}.actualresponses(ok);        newPerformance = (nr == correct);		hits = sum((nr == 1) & (correct == 1));		correctRejects = sum((nr ==0) & (correct == 0));		misses = sum((nr == 0) & (correct == 1));		falseAlarms = sum((nr == 1) & (correct == 0));		yes = sum(nr == 1);		no = sum(nr == 0);		ps = sum(correct == 1);		ns = sum(correct == 0);		nh = hits / ll;		nm = misses / ll;		ncr = correctRejects / ll;		nfa = falseAlarms / ll;		nyes = yes / ll;		nno = no / ll;		meanRT = mean(scanHistory{sesscounter}.RT(ok));		disp(sprintf('Maximal contrast value: %4.4f%', contrastvals(max(scanHistory{sesscounter}.contrast))));		disp(sprintf('Upper contrast limit: %4.4f%', params.contrastRange(2)));		disp(sprintf('Minimal contrast value: %4.4f%', contrastvals(min(scanHistory{sesscounter}.contrast))));		disp(sprintf('Lower contrast limit: %4.4f%', params.contrastRange(1)));		disp(sprintf('Percent valid trials %4.1f%%', 100*ll/length(scanHistory{sesscounter}.contrast)));		disp(sprintf('Response bias %4.1f%%', 100 * (nyes / (nyes + nno))));		disp(sprintf('Average RT %4.4f%', meanRT));		disp(sprintf('\n'));	else		disp('No responses recorded from subject for this condition');	end		scanHistory{sesscounter}.responsekey = [];	for i = 1:length(scanHistory{sesscounter}.actualresponses);		%Create the sequence key:		% -1: bad response		% 0:correct reject		% 1:miss		% 2: false alarm		% 3:hit		if isnan(scanHistory{sesscounter}.actualresponses(i))			keyValue = -1;		elseif scanHistory{sesscounter}.correctanswer(i) == 0 %stimulus absent			if scanHistory{sesscounter}.actualresponses(i) == 0 %correct reject				keyValue = 0;			elseif scanHistory{sesscounter}.actualresponses(i) == 1 %false alarm				keyValue = 2;			end		elseif scanHistory{sesscounter}.correctanswer(i) == 1 %stimulus present			if scanHistory{sesscounter}.actualresponses(i) == 0 %miss				keyValue = 1;			elseif scanHistory{sesscounter}.actualresponses(i) == 1 %hit				keyValue = 3;			end		end		scanHistory{sesscounter}.responsekey = [scanHistory{sesscounter}.responsekey keyValue];    end    %Create or update the data file    if sesscounter == 1        newsession = 1;    else        newsession = 0;    end    UpdateResults_OSX('ssfmri',params,scanHistory{sesscounter}, newsession);end% Close the one on-screen and many off-screen windowsScreen('CloseAll');Priority(0);ShowCursor;