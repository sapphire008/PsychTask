function img = insertFix_surround_fMRI(display,img,fixParams)%% img = insertFixation_OSX(display,img,fixParams)%% AUTHOR: Boynton% DATE:   February, 1998.% PURPOSE: %    Creates a fixation point using the default display%    colors of 'black' and 'white' (reserved colors).% % ARGUMENTS:% % display:      display data structure% img:          the stimulus.image % % fixParams.size:      Fixation size.  %               Default is 0.5 degrees visual angle% fixParams.colors:    Fixation color.  %               Default is reserved hi and lo colors% fixParams.Position:  Fixation position.  %               Default is center of image.fixSize = fixParams.size; % Measure image size and compute center% nRow=size(img,1);nCol=size(img,2);fixCenter = round([nRow,nCol]/2);numImages = size(img,3);if (~exist('fixParams') | ~isfield(fixParams,'colors'))  hi = getReservedColor(display,'white');  lo = getReservedColor(display,'black');  mid = display.reservedColor(getReservedColor(display, 'background')+1).gunVal(1);  %hi = display.reservedColor(findName(display.reservedColor,'white')).fbVal;  %lo = display.reservedColor(findName(display.reservedColor,'black')).fbVal;else  hi = fixParams.colors(2);  lo = fixParams.colors(1);ends = round(angle2pix(display,fixSize)/2)*2; %make the size evenly divisible by 2margin =max(floor(angle2pix(display,fixSize/4)),1);[x,y]=meshgrid([1:s],[1:s]);switch fixParams.type    case 'black_square'        fixImage = lo*ones(size(x));        if fixParams.target == 1            xloc = round(2+rand*(length(x)-2-fixParams.targetSize));            yloc = round(2+rand*(length(y)-2-fixParams.targetSize));            fixImage(xloc:xloc+(fixParams.targetSize-1), yloc:yloc+(fixParams.targetSize-1)) = 3; %3 is reserved for target luminance, set in SurroundParams_fMRI        end    case 'square'        fixImage = hi*ones(size(x));        fixImage([margin+1:size(x,1)-margin],[margin+1:size(x,2)-margin])= ...            lo*ones(size(x)-margin*2);    case 'left triangle'        fixImage = mid*ones(size(x));        quadimg = mid*ones(size(x)/2);        for xcounter = 1:size(quadimg,1)            for ycounter = 1:size(quadimg,2)                if xcounter > ycounter                    quadimg(xcounter,ycounter) = lo;                end            end        end        fixImage(1:size(quadimg,1),1:size(quadimg,2)) = fliplr(quadimg);        fixImage(size(quadimg,1)+1:size(x),1:size(quadimg,2)) = flipud(fliplr(quadimg));        xoffset = round(size(x,1)/4); tmp = mid*ones(size(x));        for xcounter = size(x,1):-1:1 %center            if xcounter - xoffset >= 1                tmp(1:size(x,1),xcounter) = fixImage(1:size(x,1),xcounter - xoffset);            end        end        fixImage = tmp;   case 'right triangle'        fixImage = mid*ones(size(x));        quadimg = mid*ones(size(x)/2);        for xcounter = 1:size(quadimg,1)            for ycounter = 1:size(quadimg,2)                if xcounter > ycounter                    quadimg(xcounter,ycounter) = lo;                end            end        end        fixImage(1:size(quadimg,1),size(quadimg,2)+1:size(y)) = quadimg;        fixImage(size(quadimg,1)+1:size(x),size(quadimg,2)+1:size(y)) = flipud(quadimg);        xoffset = round(size(x,1)/4); tmp = mid*ones(size(x));        for xcounter = 1:size(x,1)            if xcounter + xoffset <= size(x,1)                tmp(1:size(x,1),xcounter) = fixImage(1:size(x,1),xcounter + xoffset);            end        end        fixImage = tmp;    case 'diamond'        fixImage = mid*ones(size(x));        quadimg = mid*ones(size(x)/2);        for xcounter = 1:size(quadimg,1)            for ycounter = 1:size(quadimg,2)                if xcounter > ycounter                    quadimg(xcounter,ycounter) = lo;                end            end        end        fixImage(1:size(quadimg,1),1:size(quadimg,2)) = fliplr(quadimg);        fixImage(size(quadimg,1)+1:size(x),1:size(quadimg,2)) = flipud(fliplr(quadimg));        fixImage(1:size(quadimg,1),size(quadimg,2)+1:size(y)) = quadimg;        fixImage(size(quadimg,1)+1:size(x),size(quadimg,2)+1:size(y)) = flipud(quadimg);end% Find the indices corresponding to the fixation location in the% image. % id =(1:prod(size(fixImage)))';% If the fixation position is not sent in, place it in the middle% of the image.  Do this by subtracting off one-half the box size% from the fixCenter position.if (~exist('fixParams') | ~isfield(fixParams,'position'))    fixPosition = [0 0];else 	fixPosition = fixParams.position; 	disp ('Using custom fixation position');end  % If the fixation position was sent in, then it was passed in as% an angle above or below the center of the image.  So, we will% compute the image center (as above) and add in the displacement.fixOffset = ...    [-angle2pix(display,fixPosition(1)), ...	angle2pix(display,fixPosition(2))];% Specify the location (in pixels) of the bottom of the fixation.% fixCenter = fixCenter + fixOffset;fixBottom = [floor(fixCenter(2)-s/2)-1, ceil(fixCenter(1)-s/2)];% insert the fixation point into 'img' at the proper index locations.% for ii=1:numImages  img( nRow*(x(id)+fixBottom(1)) +   y(id)+fixBottom(2) + ...      (ii-1)*nRow*nCol) = fixImage(id); end%colormap(double(stimulus.cmap(:,:,1))/256); image(img)return;